"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuthController = void 0;
const crypto_1 = __importDefault(require("crypto"));
const dbutils = __importStar(require("../db/utils"));
const saml_1 = __importDefault(require("../saml/saml"));
const error_1 = require("./error");
const allowed = __importStar(require("./oauth/allowed"));
const codeVerifier = __importStar(require("./oauth/code-verifier"));
const redirect = __importStar(require("./oauth/redirect"));
const utils_1 = require("./utils");
const util_1 = require("util");
const zlib_1 = require("zlib");
const deflateRawAsync = (0, util_1.promisify)(zlib_1.deflateRaw);
const relayStatePrefix = 'boxyhq_jackson_';
function getEncodedClientId(client_id) {
    try {
        const sp = new URLSearchParams(client_id);
        const tenant = sp.get('tenant');
        const product = sp.get('product');
        if (tenant && product) {
            return {
                tenant: sp.get('tenant'),
                product: sp.get('product'),
            };
        }
        return null;
    }
    catch (err) {
        return null;
    }
}
class OAuthController {
    constructor({ configStore, sessionStore, codeStore, tokenStore, opts }) {
        this.configStore = configStore;
        this.sessionStore = sessionStore;
        this.codeStore = codeStore;
        this.tokenStore = tokenStore;
        this.opts = opts;
    }
    authorize(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { response_type = 'code', client_id, redirect_uri, state, tenant, product, code_challenge, code_challenge_method = '', 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            provider = 'saml', } = body;
            if (!redirect_uri) {
                throw new error_1.JacksonError('Please specify a redirect URL.', 400);
            }
            if (!state) {
                throw new error_1.JacksonError('Please specify a state to safeguard against XSRF attacks.', 400);
            }
            let samlConfig;
            if (tenant && product) {
                const samlConfigs = yield this.configStore.getByIndex({
                    name: utils_1.IndexNames.TenantProduct,
                    value: dbutils.keyFromParts(tenant, product),
                });
                if (!samlConfigs || samlConfigs.length === 0) {
                    throw new error_1.JacksonError('SAML configuration not found.', 403);
                }
                // TODO: Support multiple matches
                samlConfig = samlConfigs[0];
            }
            else if (client_id && client_id !== '' && client_id !== 'undefined' && client_id !== 'null') {
                // if tenant and product are encoded in the client_id then we parse it and check for the relevant config(s)
                const sp = getEncodedClientId(client_id);
                if (sp === null || sp === void 0 ? void 0 : sp.tenant) {
                    const samlConfigs = yield this.configStore.getByIndex({
                        name: utils_1.IndexNames.TenantProduct,
                        value: dbutils.keyFromParts(sp.tenant, sp.product || ''),
                    });
                    if (!samlConfigs || samlConfigs.length === 0) {
                        throw new error_1.JacksonError('SAML configuration not found.', 403);
                    }
                    // TODO: Support multiple matches
                    samlConfig = samlConfigs[0];
                }
                else {
                    samlConfig = yield this.configStore.get(client_id);
                }
            }
            else {
                throw new error_1.JacksonError('You need to specify client_id or tenant & product', 403);
            }
            if (!samlConfig) {
                throw new error_1.JacksonError('SAML configuration not found.', 403);
            }
            if (!allowed.redirect(redirect_uri, samlConfig.redirectUrl)) {
                throw new error_1.JacksonError('Redirect URL is not allowed.', 403);
            }
            const samlReq = saml_1.default.request({
                entityID: this.opts.samlAudience,
                callbackUrl: this.opts.externalUrl + this.opts.samlPath,
                signingKey: samlConfig.certs.privateKey,
            });
            const sessionId = crypto_1.default.randomBytes(16).toString('hex');
            yield this.sessionStore.put(sessionId, {
                id: samlReq.id,
                redirect_uri,
                response_type,
                state,
                code_challenge,
                code_challenge_method,
            });
            // deepak: When supporting HTTP-POST skip deflate
            const samlReqEnc = yield deflateRawAsync(samlReq.request);
            const redirectUrl = redirect.success(samlConfig.idpMetadata.sso.redirectUrl, {
                RelayState: relayStatePrefix + sessionId,
                SAMLRequest: Buffer.from(samlReqEnc).toString('base64'),
            });
            return { redirect_url: redirectUrl };
        });
    }
    samlResponse(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { SAMLResponse } = body; // RelayState will contain the sessionId from earlier quasi-oauth flow
            let RelayState = body.RelayState || '';
            if (!this.opts.idpEnabled && !RelayState.startsWith(relayStatePrefix)) {
                // IDP is disabled so block the request
                throw new error_1.JacksonError('IdP (Identity Provider) flow has been disabled. Please head to your Service Provider to login.', 403);
            }
            if (!RelayState.startsWith(relayStatePrefix)) {
                RelayState = '';
            }
            RelayState = RelayState.replace(relayStatePrefix, '');
            const rawResponse = Buffer.from(SAMLResponse, 'base64').toString();
            const parsedResp = yield saml_1.default.parseAsync(rawResponse);
            const samlConfigs = yield this.configStore.getByIndex({
                name: utils_1.IndexNames.EntityID,
                value: parsedResp === null || parsedResp === void 0 ? void 0 : parsedResp.issuer,
            });
            if (!samlConfigs || samlConfigs.length === 0) {
                throw new error_1.JacksonError('SAML configuration not found.', 403);
            }
            // TODO: Support multiple matches
            const samlConfig = samlConfigs[0];
            let session;
            if (RelayState !== '') {
                session = yield this.sessionStore.get(RelayState);
                if (!session) {
                    throw new error_1.JacksonError('Unable to validate state from the origin request.', 403);
                }
            }
            const validateOpts = {
                thumbprint: samlConfig.idpMetadata.thumbprint,
                audience: this.opts.samlAudience,
            };
            if (session && session.id) {
                validateOpts.inResponseTo = session.id;
            }
            const profile = yield saml_1.default.validateAsync(rawResponse, validateOpts);
            // store details against a code
            const code = crypto_1.default.randomBytes(20).toString('hex');
            const codeVal = {
                profile,
                clientID: samlConfig.clientID,
                clientSecret: samlConfig.clientSecret,
            };
            if (session) {
                codeVal.session = session;
            }
            yield this.codeStore.put(code, codeVal);
            if (session && session.redirect_uri && !allowed.redirect(session.redirect_uri, samlConfig.redirectUrl)) {
                throw new error_1.JacksonError('Redirect URL is not allowed.', 403);
            }
            const params = {
                code,
            };
            if (session && session.state) {
                params.state = session.state;
            }
            const redirectUrl = redirect.success((session && session.redirect_uri) || samlConfig.defaultRedirectUrl, params);
            return { redirect_url: redirectUrl };
        });
    }
    /**
     * @swagger
     *
     * /oauth/token:
     *   post:
     *     summary: Code exchange
     *     operationId: oauth-code-exchange
     *     tags:
     *       - OAuth
     *     consumes:
     *       - application/x-www-form-urlencoded
     *     parameters:
     *       - name: grant_type
     *         in: formData
     *         type: string
     *         description: Grant type should be 'authorization_code'
     *         default: authorization_code
     *         required: true
     *       - name: client_id
     *         in: formData
     *         type: string
     *         description: Use the client_id returned by the SAML config API
     *         required: true
     *       - name: client_secret
     *         in: formData
     *         type: string
     *         description: Use the client_secret returned by the SAML config API
     *         required: true
     *       - name: redirect_uri
     *         in: formData
     *         type: string
     *         description: Redirect URI
     *         required: true
     *       - name: code
     *         in: formData
     *         type: string
     *         description: Code
     *         required: true
     *     responses:
     *       '200':
     *         description: Success
     *         schema:
     *           type: object
     *           properties:
     *             access_token:
     *               type: string
     *             token_type:
     *               type: string
     *             expires_in:
     *               type: string
     *           example:
     *             access_token: 8958e13053832b5af58fdf2ee83f35f5d013dc74
     *             token_type: bearer
     *             expires_in: 300
     */
    token(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { client_id, client_secret, code_verifier, code, grant_type = 'authorization_code' } = body;
            if (grant_type !== 'authorization_code') {
                throw new error_1.JacksonError('Unsupported grant_type', 400);
            }
            if (!code) {
                throw new error_1.JacksonError('Please specify code', 400);
            }
            const codeVal = yield this.codeStore.get(code);
            if (!codeVal || !codeVal.profile) {
                throw new error_1.JacksonError('Invalid code', 403);
            }
            if (code_verifier) {
                // PKCE flow
                let cv = code_verifier;
                if (codeVal.session.code_challenge_method.toLowerCase() === 's256') {
                    cv = codeVerifier.encode(code_verifier);
                }
                if (codeVal.session.code_challenge !== cv) {
                    throw new error_1.JacksonError('Invalid code_verifier', 401);
                }
            }
            else if (client_id && client_secret) {
                // check if we have an encoded client_id
                if (client_id !== 'dummy' && client_secret !== 'dummy') {
                    const sp = getEncodedClientId(client_id);
                    if (!sp) {
                        // OAuth flow
                        if (client_id !== codeVal.clientID || client_secret !== codeVal.clientSecret) {
                            throw new error_1.JacksonError('Invalid client_id or client_secret', 401);
                        }
                    }
                }
            }
            else if (codeVal && codeVal.session) {
                throw new error_1.JacksonError('Please specify client_secret or code_verifier', 401);
            }
            // store details against a token
            const token = crypto_1.default.randomBytes(20).toString('hex');
            yield this.tokenStore.put(token, codeVal.profile);
            return {
                access_token: token,
                token_type: 'bearer',
                expires_in: this.opts.db.ttl,
            };
        });
    }
    /**
     * @swagger
     *
     * /oauth/userinfo:
     *   get:
     *     summary: Get profile
     *     operationId: oauth-get-profile
     *     tags:
     *       - OAuth
     *     responses:
     *       '200':
     *         description: Success
     *         schema:
     *           type: object
     *           properties:
     *             id:
     *               type: string
     *             email:
     *               type: string
     *             firstName:
     *               type: string
     *             lastName:
     *               type: string
     *           example:
     *             id: 32b5af58fdf
     *             email: jackson@coolstartup.com
     *             firstName: SAML
     *             lastName: Jackson
     */
    userInfo(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const rsp = yield this.tokenStore.get(token);
            if (!rsp || !rsp.claims) {
                throw new error_1.JacksonError('Invalid token', 403);
            }
            return rsp.claims;
        });
    }
}
exports.OAuthController = OAuthController;
