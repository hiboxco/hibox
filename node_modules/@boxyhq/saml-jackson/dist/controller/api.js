"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIController = void 0;
const crypto_1 = __importDefault(require("crypto"));
const dbutils = __importStar(require("../db/utils"));
const saml_1 = __importDefault(require("../saml/saml"));
const x509_1 = __importDefault(require("../saml/x509"));
const error_1 = require("./error");
const utils_1 = require("./utils");
class APIController {
    constructor({ configStore }) {
        this.configStore = configStore;
    }
    _validateIdPConfig(body) {
        const { encodedRawMetadata, rawMetadata, defaultRedirectUrl, redirectUrl, tenant, product } = body;
        if (!rawMetadata && !encodedRawMetadata) {
            throw new error_1.JacksonError('Please provide rawMetadata or encodedRawMetadata', 400);
        }
        if (!defaultRedirectUrl) {
            throw new error_1.JacksonError('Please provide a defaultRedirectUrl', 400);
        }
        if (!redirectUrl) {
            throw new error_1.JacksonError('Please provide redirectUrl', 400);
        }
        if (!tenant) {
            throw new error_1.JacksonError('Please provide tenant', 400);
        }
        if (!product) {
            throw new error_1.JacksonError('Please provide product', 400);
        }
    }
    /**
     * @swagger
     *
     * /api/v1/saml/config:
     *   post:
     *     summary: Create SAML configuration
     *     operationId: create-saml-config
     *     tags: [SAML Config]
     *     produces:
     *       - application/json
     *     consumes:
     *       - application/x-www-form-urlencoded
     *     parameters:
     *       - name: encodedRawMetadata
     *         description: Base64 encoding of the XML metadata
     *         in: formData
     *         required: true
     *         type: string
     *       - name: defaultRedirectUrl
     *         description: The redirect URL to use in the IdP login flow
     *         in: formData
     *         required: true
     *         type: string
     *         example: http://localhost:3000/login/saml
     *       - name: redirectUrl
     *         description: JSON encoded array containing a list of allowed redirect URLs
     *         in: formData
     *         required: true
     *         type: string
     *         example: '["http://localhost:3000/*"]'
     *       - name: tenant
     *         description: Tenant
     *         in: formData
     *         required: true
     *         type: string
     *         example: boxyhq.com
     *       - name: product
     *         description: Product
     *         in: formData
     *         required: true
     *         type: string
     *         example: demo
     *     responses:
     *       200:
     *         description: Success
     *         schema:
     *           type: object
     *           properties:
     *             client_id:
     *               type: string
     *             client_secret:
     *               type: string
     *             provider:
     *               type: string
     *           example:
     *             client_id: 8958e13053832b5af58fdf2ee83f35f5d013dc74
     *             client_secret: 13f01f4df5b01770c616e682d14d3ba23f20948cfa89b1d7
     *             type: accounts.google.com
     *       401:
     *         description: Unauthorized
     */
    config(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { encodedRawMetadata, rawMetadata, defaultRedirectUrl, redirectUrl, tenant, product } = body;
            this._validateIdPConfig(body);
            let metaData = rawMetadata;
            if (encodedRawMetadata) {
                metaData = Buffer.from(encodedRawMetadata, 'base64').toString();
            }
            const idpMetadata = yield saml_1.default.parseMetadataAsync(metaData);
            // extract provider
            let providerName = extractHostName(idpMetadata.entityID);
            if (!providerName) {
                providerName = extractHostName(idpMetadata.sso.redirectUrl || idpMetadata.sso.postUrl);
            }
            idpMetadata.provider = providerName ? providerName : 'Unknown';
            const clientID = dbutils.keyDigest(dbutils.keyFromParts(tenant, product, idpMetadata.entityID));
            let clientSecret;
            const exists = yield this.configStore.get(clientID);
            if (exists) {
                clientSecret = exists.clientSecret;
            }
            else {
                clientSecret = crypto_1.default.randomBytes(24).toString('hex');
            }
            const certs = yield x509_1.default.generate();
            if (!certs) {
                throw new Error('Error generating x59 certs');
            }
            yield this.configStore.put(clientID, {
                idpMetadata,
                defaultRedirectUrl,
                redirectUrl: JSON.parse(redirectUrl),
                tenant,
                product,
                clientID,
                clientSecret,
                certs,
            }, {
                // secondary index on entityID
                name: utils_1.IndexNames.EntityID,
                value: idpMetadata.entityID,
            }, {
                // secondary index on tenant + product
                name: utils_1.IndexNames.TenantProduct,
                value: dbutils.keyFromParts(tenant, product),
            });
            return {
                client_id: clientID,
                client_secret: clientSecret,
                provider: idpMetadata.provider,
            };
        });
    }
    /**
     * @swagger
     *
     * /api/v1/saml/config:
     *   get:
     *     summary: Get SAML configuration
     *     operationId: get-saml-config
     *     tags:
     *       - SAML Config
     *     parameters:
     *       - in: query
     *         name: tenant
     *         type: string
     *         description: Tenant
     *         example: boxyhq.com
     *       - in: query
     *         name: product
     *         type: string
     *         description: Product
     *         example: demo
     *       - in: query
     *         name: clientID
     *         type: string
     *         description: Client ID
     *     responses:
     *       '200':
     *         description: Success
     *         schema:
     *           type: object
     *           properties:
     *             provider:
     *               type: string
     *           example:
     *             type: accounts.google.com
     *       '401':
     *         description: Unauthorized
     */
    getConfig(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { clientID, tenant, product } = body;
            if (clientID) {
                const samlConfig = yield this.configStore.get(clientID);
                return samlConfig ? { provider: samlConfig.idpMetadata.provider } : {};
            }
            if (tenant && product) {
                const samlConfigs = yield this.configStore.getByIndex({
                    name: utils_1.IndexNames.TenantProduct,
                    value: dbutils.keyFromParts(tenant, product),
                });
                if (!samlConfigs || !samlConfigs.length) {
                    return {};
                }
                return { provider: samlConfigs[0].idpMetadata.provider };
            }
            throw new error_1.JacksonError('Please provide `clientID` or `tenant` and `product`.', 400);
        });
    }
    /**
     * @swagger
     * /api/v1/saml/config:
     *   delete:
     *     summary: Delete SAML configuration
     *     operationId: delete-saml-config
     *     tags:
     *       - SAML Config
     *     consumes:
     *       - application/x-www-form-urlencoded
     *     parameters:
     *       - name: clientID
     *         in: formData
     *         type: string
     *         required: true
     *         description: Client ID
     *       - name: clientSecret
     *         in: formData
     *         type: string
     *         required: true
     *         description: Client Secret
     *       - name: tenant
     *         in: formData
     *         type: string
     *         description: Tenant
     *         example: boxyhq.com
     *       - name: product
     *         in: formData
     *         type: string
     *         description: Product
     *         example: demo
     *     responses:
     *       '200':
     *         description: Success
     *       '401':
     *         description: Unauthorized
     */
    deleteConfig(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { clientID, clientSecret, tenant, product } = body;
            if (clientID && clientSecret) {
                const samlConfig = yield this.configStore.get(clientID);
                if (!samlConfig) {
                    return;
                }
                if (samlConfig.clientSecret === clientSecret) {
                    yield this.configStore.delete(clientID);
                }
                else {
                    throw new error_1.JacksonError('clientSecret mismatch.', 400);
                }
                return;
            }
            if (tenant && product) {
                const samlConfigs = yield this.configStore.getByIndex({
                    name: utils_1.IndexNames.TenantProduct,
                    value: dbutils.keyFromParts(tenant, product),
                });
                if (!samlConfigs || !samlConfigs.length) {
                    return;
                }
                for (const conf of samlConfigs) {
                    yield this.configStore.delete(conf.clientID);
                }
                return;
            }
            throw new error_1.JacksonError('Please provide `clientID` and `clientSecret` or `tenant` and `product`.', 400);
        });
    }
}
exports.APIController = APIController;
const extractHostName = (url) => {
    try {
        const pUrl = new URL(url);
        if (pUrl.hostname.startsWith('www.')) {
            return pUrl.hostname.substring(4);
        }
        return pUrl.hostname;
    }
    catch (err) {
        return null;
    }
};
