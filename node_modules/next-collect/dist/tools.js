"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = exports.mapKeys = exports.deepMerge = exports.splitObject = exports.asArray = exports.deepClone = exports.deepGet = exports.deepDelete = exports.deepSet = exports.isObject = exports.createPrefixMap = exports.removeProps = exports.renameProps = exports.sanitizeObject = exports.removeSuffix = void 0;
function removeSuffix(str, suffix) {
    const suffixes = typeof suffix === "string" ? [suffix] : suffix;
    for (const suff of suffixes) {
        while (str.lastIndexOf(suff) === str.length - suff.length) {
            str = str.substring(0, str.length - suff.length);
        }
    }
    return str;
}
exports.removeSuffix = removeSuffix;
/**
 * Removes all undefined values from object tree
 */
function sanitizeObject(object, opts = {}) {
    const { undefs = "remove", removeFunctions = false } = opts;
    if (object === null) {
        throw new Error(`sanitizeObject(null) can't be called`);
    }
    if (typeof object !== "object") {
        throw new Error(`Wrong type ${typeof object} - expected object`);
    }
    if (Array.isArray(object)) {
        return (undefs === "remove" ? object.filter(element => element !== undefined) : object).map(element => {
            if (element === undefined) {
                return null;
            }
            else if (typeof element === "object") {
                return sanitizeObject(element, opts);
            }
            else {
                return element;
            }
        });
    }
    return (undefs === "remove" ? Object.entries(object).filter(([, value]) => value !== undefined) : Object.entries(object)).reduce((res, [key, value]) => {
        if (value === undefined || value === null) {
            return { ...res, [key]: null };
        }
        else if (typeof value === "object") {
            return { ...res, [key]: sanitizeObject(value, opts) };
        }
        else {
            return { ...res, [key]: value };
        }
    }, {});
}
exports.sanitizeObject = sanitizeObject;
function renameProps(obj, rename) {
    return Object.entries(obj).reduce((res, [key, value]) => ({ ...res, [rename[key] || key]: value }), {});
}
exports.renameProps = renameProps;
function removeProps(obj, ...props) {
    const propSet = new Set(props);
    return Object.entries(obj)
        .filter(([key]) => propSet.has(key))
        .reduce((res, [key, value]) => ({ ...res, [key]: value }), {});
}
exports.removeProps = removeProps;
function createPrefixMap(map) {
    const prefixes = [];
    const suffixes = [];
    const fullUrls = new Map();
    for (const [key, val] of map) {
        const firstWildcard = key.indexOf("*");
        const lastWildcard = key.lastIndexOf("*");
        if (firstWildcard < 0 && lastWildcard < 0) {
            fullUrls.set(key, val);
        }
        else if (firstWildcard >= 0 && lastWildcard >= 0 && firstWildcard !== lastWildcard) {
            throw new Error(`Invalid pattern ${key}. So far we support only one wildcard that should be at the end or beginning of url. Found at least two wildcards`);
        }
        else if (firstWildcard === key.length - 1) {
            prefixes.push([key.substring(0, key.length - 1), val]);
        }
        else if (firstWildcard === 0) {
            suffixes.push([key.substring(1), val]);
        }
        else {
            throw new Error(`Invalid pattern ${key}. So far we support only one wildcard that should be at the end or beginning of url. Found at least two wildcards`);
        }
    }
    return {
        get(element) {
            const fullMatch = fullUrls.get(element);
            if (fullMatch !== undefined) {
                return fullMatch;
            }
            const prefixMatch = prefixes.find(([key]) => element.startsWith(key));
            if (prefixMatch && prefixMatch[1] === null) {
                return prefixMatch[1];
            }
            const suffixMatch = suffixes.find(([key]) => element.endsWith(key));
            if (suffixMatch && suffixMatch[1] === null) {
                return suffixMatch[1];
            }
            return (prefixMatch || suffixMatch || [undefined, undefined])[1];
        },
    };
}
exports.createPrefixMap = createPrefixMap;
function isObject(object) {
    return object && typeof object === "object" && !Array.isArray(object);
}
exports.isObject = isObject;
function deepSet(obj, _path, val) {
    const path = [..._path];
    if (path.length === 1) {
        obj[path[0]] = val;
        return;
    }
    const key = path.shift();
    if (obj[key] === undefined) {
        obj[key] = {};
    }
    deepSet(obj[key], path, val);
}
exports.deepSet = deepSet;
function deepDelete(obj, path) {
    if (path.length === 1) {
        delete obj[path[0]];
        return;
    }
    const key = path.shift();
    if (obj[key] !== undefined) {
        deepDelete(obj[key], path);
    }
}
exports.deepDelete = deepDelete;
function deepGet(obj, _path) {
    const path = [..._path];
    if (path.length === 1) {
        return obj[path[0]];
    }
    const key = path.shift();
    if (obj[key] === undefined) {
        return undefined;
    }
    return deepGet(obj[key], path);
}
exports.deepGet = deepGet;
function deepClone(obj) {
    if (typeof obj !== "object" || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(deepClone);
    }
    return Object.entries(obj).reduce((res, [key, val]) => ({ ...res, [key]: deepClone(val) }), {});
}
exports.deepClone = deepClone;
function asArray(v) {
    return Array.isArray(v) ? v : [v];
}
exports.asArray = asArray;
function splitObject(obj, props) {
    const base = {};
    const extra = deepClone(obj);
    const paths = props.map(prop => (Array.isArray(prop) ? prop : [prop]));
    for (const path of paths) {
        const val = deepGet(obj, path);
        deepSet(base, path, val);
        deepDelete(extra, path);
    }
    return [base, extra];
}
exports.splitObject = splitObject;
function deepMerge(target, ...sources) {
    if (!sources.length) {
        return target;
    }
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key]) {
                    Object.assign(target, { [key]: {} });
                }
                deepMerge(target[key], source[key]);
            }
            else if (source[key] !== undefined) {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return deepMerge(target, ...sources);
}
exports.deepMerge = deepMerge;
function mapKeys(obj, f) {
    return Object.entries(obj)
        .map(([key, val]) => [f(key), val])
        .reduce((res, [key, val]) => ({ ...res, [key]: val }), {});
}
exports.mapKeys = mapKeys;
function flatten(data, opts) {
    return Object.entries(data).reduce((res, [key, value]) => {
        if ((opts?.stopPaths || []).find(path => path === key || (path.length === 1 && path[0] === key))) {
            return { ...res, [key]: value };
        }
        if (value === undefined || value === null) {
            return { ...res, [key]: null };
        }
        else if (Array.isArray(value)) {
            return { ...res, [key]: JSON.stringify(value) };
        }
        else if (typeof value === "object") {
            const flatChild = mapKeys(flatten(value, {
                ...opts,
                stopPaths: opts?.stopPaths &&
                    opts?.stopPaths.filter(path => Array.isArray(path) && path.length > 1).map(path => path.slice(1)),
            }), k => `${key}${opts?.delimiter || "_"}${k}`);
            return { ...res, ...flatChild };
        }
        else {
            return { ...res, [key]: value };
        }
    }, {});
}
exports.flatten = flatten;
