"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.postgrestDriver = void 0;
const index_1 = require("../index");
const tools_1 = require("../tools");
const version_1 = require("../version");
const remote_1 = require("../remote");
function getTableFromUrl(url) {
    const parts = url
        .split("/")
        .map(el => el.trim())
        .filter(el => el && el !== "");
    return parts[parts.length - 1];
}
const defaultDataTypes = {
    httpMethod: "TEXT",
    user: null,
    timestamp: "TIMESTAMP",
    clickIds: null,
    eventId: "TEXT",
    eventType: "TEXT",
    host: "TEXT",
    ipAddress: "TEXT",
    localTimezoneOffset: "INTEGER",
    path: "TEXT",
    queryString: "TEXT",
    referrer: "TEXT",
    screenResolution: "TEXT",
    title: "TEXT",
    url: "TEXT",
    userAgent: "TEXT",
    userLanguage: "TEXT",
    utms: null,
    viewportSize: "TEXT",
};
function guessDataType(field, value) {
    const defaultType = defaultDataTypes[field];
    if (defaultType) {
        return defaultType;
    }
    if (value && typeof value === "object") {
        return "JSONB DEFAULT '{}'::JSONB";
    }
    if (typeof value === "string") {
        return "TEXT";
    }
    else if (typeof value === "boolean") {
        return "BOOLEAN";
    }
    else if (typeof value === "number") {
        return "DOUBLE PRECISION";
    }
    else {
        return "TEXT";
    }
}
function ddl(tableName, _object) {
    const object = { ..._object, user: _object.user || {} };
    console.log("Guessing ddl for", object);
    object.user.id = object.user.id || "";
    object.user.email = object.user.email || "";
    object.user.email = object.user.anonymousId || "";
    const statements = Object.entries(object)
        .map(([field, value]) => [field, guessDataType(field, value)])
        .filter(([, type]) => !!type)
        .map(([field, type]) => `ALTER TABLE "${tableName}"
        ADD COLUMN IF NOT EXISTS "${field}" ${type}`);
    //`ALTER TABLE "${tableName}" ADD COLUMN IF NOT EXISTS "${field}" ${guessDataType(field, value)}`
    statements.push(`ALTER TABLE "${tableName}"
      ADD CONSTRAINT ${tableName.toLowerCase()}_pkey PRIMARY KEY ("eventId")`);
    return statements.join(";\n") + ";";
}
function parseQueryString(queryString) {
    return queryString
        .substring(queryString.indexOf("?") + 1)
        .split("&")
        .reduce((res, pair) => {
        const [key, value] = pair.split("=");
        return { ...res, [key]: value && decodeURIComponent(value) };
    }, {});
}
async function upsert(event, ctx, opts) {
    const url = opts.url || process.env.POSTGREST_URL;
    const apiKey = opts?.apiKey || process.env.POSTGREST_API_KEY;
    const keepColumns = [
        ...index_1.defaultPageEventProps,
        ["page"],
        ["user", "email"],
        ["user", "id"],
        ["user", "anonymousId"],
        ...(opts?.extraColumns || []),
    ];
    const [base, extra] = (0, tools_1.splitObject)(event, keepColumns);
    const objectToInsert = {
        ...(0, tools_1.flatten)(base, { stopPaths: ["utms", "clickIds", "page"] }),
        extra,
        timestamp: base.timestamp || new Date(),
        queryParams: event.queryString && event.queryString.length > 0 ? parseQueryString(event.queryString) : {},
    };
    if (!url) {
        throw new Error(`Please define opts.url or env.POSTGREST_URL`);
    }
    if (!apiKey) {
        throw new Error(`Please define opts.apiKey or env.POSTGREST_API_KEY`);
    }
    const headers = {
        apikey: apiKey,
        //    Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        Accept: "application/json",
        Prefer: "resolution=merge-duplicates",
        "User-Agent": (0, version_1.getUserAgent)(),
    };
    (0, remote_1.remoteCall)(url, {
        method: "POST",
        headers,
        payload: objectToInsert,
    })
        .then(response => {
        if ((0, index_1.isDebug)()) {
            console.log(`Successfully sent event to ${url}: ${JSON.stringify(objectToInsert)}. Response: ${response}`);
        }
    })
        .catch(err => {
        console.warn(`[WARN] failed to send data to ${url}\n\nPlease make sure that schema is matching data by running this script:\n\n${ddl(getTableFromUrl(url), objectToInsert)}\n\n`, err);
    });
}
const postgrestDriver = opts => {
    return (event, ctx) => upsert(event, ctx, opts);
};
exports.postgrestDriver = postgrestDriver;
