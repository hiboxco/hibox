"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pageMiddlewareShim = exports.nextApiShim = exports.defaultCookieName = void 0;
const index_1 = require("./index");
const cookie_1 = require("cookie");
const tools_1 = require("./tools");
exports.defaultCookieName = "_next-collect_id";
const getSingleHeader = (header) => header && Array.isArray(header) ? header?.[0] : header;
exports.nextApiShim = {
    getAnonymousId(cookieName, cookieDomain, req, res, url) {
        if (cookieName === null) {
            return undefined;
        }
        else if (cookieName === undefined) {
            cookieName = exports.defaultCookieName;
        }
        const id = req.cookies[cookieName];
        if (id) {
            return id;
        }
        else {
            const newId = (0, index_1.randomId)();
            res.setHeader("set-cookie", (0, cookie_1.serialize)(cookieName, newId, {
                path: "/",
                maxAge: 60 * 60 * 24 * 365 * 10,
                secure: url.protocol === "https",
                sameSite: url.protocol === "https" ? "strict" : "lax",
                domain: cookieDomain || undefined,
            }));
            return newId;
        }
    },
    getPageEvent(eventType, url, anonymousId, req) {
        const acceptLanguageHeader = getSingleHeader(req.headers["accept-language"]);
        const clickIds = (0, index_1.getClickIdsFromQueryString)(url.queryString);
        const utms = (0, index_1.getUtmsFromQueryString)(url.queryString);
        return {
            httpMethod: req.method || "UNKNOWN",
            timestamp: new Date(),
            eventId: (0, index_1.randomId)(),
            eventType,
            ipAddress: (getSingleHeader(req.headers["x-real-ip"]) ||
                getSingleHeader(req.headers["x-forwarded-for"]) ||
                req.socket.remoteAddress ||
                "127.0.0.1")
                .split(",")[0]
                .trim(),
            userLanguage: (acceptLanguageHeader && acceptLanguageHeader.split(",")[0]) || undefined,
            clickIds,
            host: (0, index_1.getHostWithPort)(url),
            path: url.path,
            queryString: (0, index_1.getQueryString)(url),
            referrer: getSingleHeader(req.headers["referer"]) || undefined,
            url: (0, index_1.getFullUrl)(url),
            userAgent: getSingleHeader(req.headers["user-agent"]) || undefined,
            utms,
            user: {
                anonymousId: anonymousId,
            },
        };
    },
    parsePublicUrl(req) {
        const getProtocolFromUrl = (url) => url && (url.indexOf("https://") === 0 ? "https" : "http");
        const [host, maybePort] = (getSingleHeader(req.headers["x-forwarded-host"]) ||
            getSingleHeader(req.headers["host"]) ||
            "localhost").split(":");
        const protocol = (0, tools_1.removeSuffix)(getSingleHeader(req.headers["x-forwarded-proto"]) || getProtocolFromUrl(req.url) || "http", ["/", ":"]);
        const port = (0, index_1.isDefaultPort)(protocol, maybePort || req.socket.localPort?.toString());
        if (!req.url) {
            throw new Error("Invalid request - url is not defined");
        }
        const parsedUrl = new URL(req.url, `${protocol}://${host}`);
        const queryString = [...parsedUrl.searchParams.entries()].reduce((map, [key, val]) => ({ ...map, [key]: val }), {});
        return { host, path: parsedUrl.pathname, protocol, port, queryString };
    },
};
exports.pageMiddlewareShim = {
    parsePublicUrl(req) {
        const [host, maybePort] = (req.headers.get("x-forwarded-host") ||
            req.headers.get("host") ||
            req.nextUrl.host ||
            "localhost").split(":");
        const protocol = (0, tools_1.removeSuffix)(req.headers.get("x-forwarded-proto") || req.nextUrl.protocol || "http", [
            "/",
            ":",
        ]);
        const port = (0, index_1.isDefaultPort)(protocol, maybePort || req.nextUrl.port);
        const path = req.nextUrl.pathname;
        const queryString = [...req.nextUrl.searchParams.entries()].reduce((map, [key, val]) => ({ ...map, [key]: val }), {});
        return { host, path, protocol, port, queryString };
    },
    getAnonymousId(cookieName, cookieDomain, req, res, url) {
        if (cookieName === null) {
            return undefined;
        }
        else if (cookieName === undefined) {
            cookieName = exports.defaultCookieName;
        }
        const id = req.cookies.get(cookieName);
        if (id) {
            return id;
        }
        else {
            const newId = (0, index_1.randomId)();
            res.headers.set("set-cookie", (0, cookie_1.serialize)(cookieName, newId, {
                path: "/",
                maxAge: 60 * 60 * 24 * 365 * 10,
                secure: url.protocol === "https",
                sameSite: url.protocol === "https" ? "strict" : "lax",
                domain: cookieDomain || undefined,
            }));
            return newId;
        }
    },
    getPageEvent(eventType, url, anonymousId, req) {
        const acceptLanguageHeader = req.headers.get("accept-language");
        const clickIds = (0, index_1.getClickIdsFromQueryString)(url.queryString);
        const utms = (0, index_1.getUtmsFromQueryString)(url.queryString);
        return {
            httpMethod: req.method || "UNKNOWN",
            timestamp: new Date(),
            eventId: (0, index_1.randomId)(),
            eventType,
            ipAddress: (req.headers.get("x-real-ip") || req.headers.get("x-forwarded-for") || req.ip || "127.0.0.1")
                .split(",")[0]
                .trim(),
            userLanguage: (acceptLanguageHeader && acceptLanguageHeader.split(",")[0]) || undefined,
            clickIds,
            host: (0, index_1.getHostWithPort)(url),
            path: url.path,
            queryString: (0, index_1.getQueryString)(url),
            referrer: req.headers.get("referer") || undefined,
            url: (0, index_1.getFullUrl)(url),
            userAgent: req.headers.get("user-agent") || undefined,
            utms,
            user: {
                anonymousId: anonymousId,
            },
        };
    },
};
