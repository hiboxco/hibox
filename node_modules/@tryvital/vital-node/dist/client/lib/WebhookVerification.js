"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTestHeaderString = exports.signature = void 0;
// Based on https://github.com/stripe/stripe-node#webhook-signing
var crypto = require("crypto");
var utils_1 = require("./utils");
var Error_1 = require("./Error");
function parseHeader(header, scheme) {
    if (typeof header !== 'string') {
        return null;
    }
    return header.split(',').reduce(function (accum, item) {
        var kv = item.split('=');
        if (kv[0] === 't') {
            accum.timestamp = +kv[1];
        }
        if (kv[0] === scheme) {
            accum.signatures.push(kv[1]);
        }
        return accum;
    }, {
        timestamp: -1,
        signatures: [],
    });
}
exports.signature = {
    EXPECTED_SCHEME: 'v1',
    _computeSignature: function (payload, secret) {
        return crypto
            .createHmac('sha256', secret)
            .update(payload, 'utf8')
            .digest('hex');
    },
    verifyHeader: function (payload, header, secret, tolerance) {
        if (tolerance === void 0) { tolerance = null; }
        payload = Buffer.isBuffer(payload) ? payload.toString('utf8') : payload;
        // Express's type for `Request#headers` is `string | []string`
        // which is because the `set-cookie` header is an array,
        // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)
        // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)
        if (Array.isArray(header)) {
            throw new Error('Unexpected: An array was passed as a header, which should not be possible for the vital-signature header.');
        }
        header = Buffer.isBuffer(header) ? header.toString('utf8') : header;
        var details = parseHeader(header, 'v1');
        if (!details || details.timestamp === -1) {
            throw new Error_1.VitalSignatureVerificationError({
                message: 'Unable to extract timestamp and signatures from header',
                detail: {
                    header: header,
                    payload: payload,
                },
            });
        }
        if (!details.signatures.length) {
            throw new Error_1.VitalSignatureVerificationError({
                message: 'No signatures found with expected scheme',
                detail: {
                    header: header,
                    payload: payload,
                },
            });
        }
        var expectedSignature = this._computeSignature(details.timestamp + "." + payload, secret);
        var signatureFound = !!details.signatures.filter(utils_1.utils.secureCompare.bind(utils_1.utils, expectedSignature)).length;
        if (!signatureFound) {
            throw new Error_1.VitalSignatureVerificationError({
                message: 'No signatures found matching the expected signature for payload.' +
                    ' Are you passing the raw request body you received from Vital?',
                detail: {
                    header: header,
                    payload: payload,
                },
            });
        }
        var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;
        if (tolerance > 0 && timestampAge > tolerance) {
            throw new Error_1.VitalSignatureVerificationError({
                message: 'Timestamp outside the tolerance zone',
                detail: {
                    header: header,
                    payload: payload,
                },
            });
        }
        return true;
    },
};
function generateTestHeaderString(opts) {
    if (!opts) {
        throw new Error_1.VitalError({
            message: 'Options are required',
        });
    }
    opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);
    opts.scheme = opts.scheme || 'v1';
    opts.signature =
        opts.signature ||
            exports.signature._computeSignature(opts.timestamp + "." + opts.payload, opts.secret);
    var generatedHeader = [
        "t=" + opts.timestamp,
        opts.scheme + "=" + opts.signature,
    ].join(',');
    return generatedHeader;
}
exports.generateTestHeaderString = generateTestHeaderString;
