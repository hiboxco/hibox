"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = exports.WebhookVerificationError = exports.Svix = void 0;
const index_1 = require("./openapi/index");
__exportStar(require("./openapi/models/all"), exports);
__exportStar(require("./openapi/apis/exception"), exports);
const utf8 = require("@stablelib/utf8");
const base64 = require("@stablelib/base64");
const sha256 = require("fast-sha256");
const WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;
const VERSION = "0.42.3";
class UserAgentMiddleware {
    pre(context) {
        context.setHeaderParam("User-Agent", `svix-libs/${VERSION}/javascript`);
        return Promise.resolve(context);
    }
    post(context) {
        return Promise.resolve(context);
    }
}
class Svix {
    constructor(token, options = {}) {
        var _a;
        const baseUrl = (_a = options.serverUrl) !== null && _a !== void 0 ? _a : "https://api.svix.com";
        const baseServer = new index_1.ServerConfiguration(baseUrl, {});
        const bearerConfiguration = {
            tokenProvider: {
                getToken: () => token,
            },
        };
        const config = index_1.createConfiguration({
            baseServer,
            promiseMiddleware: [new UserAgentMiddleware()],
            authMethods: {
                HTTPBearer: bearerConfiguration,
            },
        });
        this._configuration = config;
        this.authentication = new Authentication(config);
        this.application = new Application(config);
        this.endpoint = new Endpoint(config);
        this.eventType = new EventType(config);
        this.message = new Message(config);
        this.messageAttempt = new MessageAttempt(config);
    }
}
exports.Svix = Svix;
class Authentication {
    constructor(config) {
        this.api = new index_1.AuthenticationApi(config);
    }
    dashboardAccess(appId) {
        return this.api.getDashboardAccessApiV1AuthDashboardAccessAppIdPost({ appId });
    }
    logout() {
        return this.api.logoutApiV1AuthLogoutPost({});
    }
}
class Application {
    constructor(config) {
        this.api = new index_1.ApplicationApi(config);
    }
    list(options) {
        return this.api.listApplicationsApiV1AppGet(Object.assign({}, options));
    }
    create(applicationIn) {
        return this.api.createApplicationApiV1AppPost({ applicationIn });
    }
    get(appId) {
        return this.api.getApplicationApiV1AppAppIdGet({ appId });
    }
    update(appId, applicationIn) {
        return this.api.updateApplicationApiV1AppAppIdPut({ appId, applicationIn });
    }
    delete(appId) {
        return this.api.deleteApplicationApiV1AppAppIdDelete({ appId });
    }
}
class Endpoint {
    constructor(config) {
        this.api = new index_1.EndpointApi(config);
    }
    list(appId, options) {
        return this.api.listEndpointsApiV1AppAppIdEndpointGet(Object.assign({ appId }, options));
    }
    create(appId, endpointIn) {
        return this.api.createEndpointApiV1AppAppIdEndpointPost({ appId, endpointIn });
    }
    get(appId, endpointId) {
        return this.api.getEndpointApiV1AppAppIdEndpointEndpointIdGet({ endpointId, appId });
    }
    update(appId, endpointId, endpointUpdate) {
        return this.api.updateEndpointApiV1AppAppIdEndpointEndpointIdPut({
            appId,
            endpointId,
            endpointUpdate,
        });
    }
    delete(appId, endpointId) {
        return this.api.deleteEndpointApiV1AppAppIdEndpointEndpointIdDelete({
            endpointId,
            appId,
        });
    }
    getSecret(appId, endpointId) {
        return this.api.getEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretGet({
            endpointId,
            appId,
        });
    }
    rotateSecret(appId, endpointId, endpointSecretRotateIn) {
        return this.api.rotateEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretRotatePost({
            endpointId,
            appId,
            endpointSecretRotateIn,
        });
    }
    recover(appId, endpointId, recoverIn) {
        return this.api
            .recoverFailedWebhooksApiV1AppAppIdEndpointEndpointIdRecoverPost({
            appId,
            endpointId,
            recoverIn,
        })
            .then(() => Promise.resolve());
    }
    getHeaders(appId, endpointId) {
        return this.api.getEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersGet({
            appId,
            endpointId,
        });
    }
    updateHeaders(appId, endpointId, endpointHeadersIn) {
        return this.api.updateEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPut({
            appId,
            endpointId,
            endpointHeadersIn,
        });
    }
    patchHeaders(appId, endpointId, endpointHeadersIn) {
        return this.api.patchEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPatch({
            appId,
            endpointId,
            endpointHeadersIn,
        });
    }
}
class EventType {
    constructor(config) {
        this.api = new index_1.EventTypeApi(config);
    }
    list(options) {
        return this.api.listEventTypesApiV1EventTypeGet(Object.assign({}, options));
    }
    get(eventTypeName) {
        return this.api.getEventTypeApiV1EventTypeEventTypeNameGet({ eventTypeName });
    }
    create(eventTypeIn) {
        return this.api.createEventTypeApiV1EventTypePost({ eventTypeIn });
    }
    update(eventTypeName, eventTypeUpdate) {
        return this.api.updateEventTypeApiV1EventTypeEventTypeNamePut({
            eventTypeName,
            eventTypeUpdate,
        });
    }
    delete(eventTypeName) {
        return this.api.deleteEventTypeApiV1EventTypeEventTypeNameDelete({ eventTypeName });
    }
}
class Message {
    constructor(config) {
        this.api = new index_1.MessageApi(config);
    }
    list(appId, options) {
        return this.api.listMessagesApiV1AppAppIdMsgGet(Object.assign({ appId }, options));
    }
    create(appId, messageIn) {
        return this.api.createMessageApiV1AppAppIdMsgPost({ appId, messageIn });
    }
    get(appId, msgId) {
        return this.api.getMessageApiV1AppAppIdMsgMsgIdGet({ msgId, appId });
    }
}
class MessageAttempt {
    constructor(config) {
        this.api = new index_1.MessageAttemptApi(config);
    }
    list(appId, msgId, options) {
        return this.api.listAttemptsApiV1AppAppIdMsgMsgIdAttemptGet(Object.assign({ appId,
            msgId }, options));
    }
    get(appId, msgId, attemptId) {
        return this.api.getAttemptApiV1AppAppIdMsgMsgIdAttemptAttemptIdGet({
            attemptId,
            msgId,
            appId,
        });
    }
    resend(appId, msgId, endpointId) {
        return this.api.resendWebhookApiV1AppAppIdMsgMsgIdEndpointEndpointIdResendPost({
            endpointId,
            msgId,
            appId,
        });
    }
    listAttemptedMessages(appId, endpointId, options) {
        return this.api.listAttemptedMessagesApiV1AppAppIdEndpointEndpointIdMsgGet(Object.assign({ appId,
            endpointId }, options));
    }
    listAttemptedDestinations(appId, msgId, options) {
        return this.api.listAttemptedDestinationsApiV1AppAppIdMsgMsgIdEndpointGet(Object.assign({ appId,
            msgId }, options));
    }
    listAttemptsForEndpoint(appId, msgId, endpointId, options) {
        return this.api.listAttemptsForEndpointApiV1AppAppIdMsgMsgIdEndpointEndpointIdAttemptGet(Object.assign({ appId, msgId, endpointId }, options));
    }
}
class ExtendableError extends Error {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, ExtendableError.prototype);
        this.name = "ExtendableError";
        this.stack = new Error(message).stack;
    }
}
class WebhookVerificationError extends ExtendableError {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, WebhookVerificationError.prototype);
        this.name = "WebhookVerificationError";
    }
}
exports.WebhookVerificationError = WebhookVerificationError;
class Webhook {
    constructor(secret) {
        if (secret.startsWith(Webhook.prefix)) {
            secret = secret.substr(Webhook.prefix.length);
        }
        this.key = base64.decode(secret);
    }
    verify(payload, headers_) {
        const headers = {};
        for (const key of Object.keys(headers_)) {
            headers[key.toLowerCase()] = headers_[key];
        }
        let msgId = headers["svix-id"];
        let msgSignature = headers["svix-signature"];
        let msgTimestamp = headers["svix-timestamp"];
        if (!msgSignature || !msgId || !msgTimestamp) {
            msgId = headers["webhook-id"];
            msgSignature = headers["webhook-signature"];
            msgTimestamp = headers["webhook-timestamp"];
            if (!msgSignature || !msgId || !msgTimestamp) {
                throw new WebhookVerificationError("Missing required headers");
            }
        }
        const timestamp = this.verifyTimestamp(msgTimestamp);
        const computedSignature = this.sign(msgId, timestamp, payload);
        const expectedSignature = computedSignature.split(",")[1];
        const passedSignatures = msgSignature.split(" ");
        for (const versionedSignature of passedSignatures) {
            const [version, signature] = versionedSignature.split(",");
            if (version !== "v1") {
                continue;
            }
            if (signature === expectedSignature) {
                return JSON.parse(payload);
            }
        }
        throw new WebhookVerificationError("No matching signature found");
    }
    sign(msgId, timestamp, payload) {
        const toSign = utf8.encode(`${msgId}.${timestamp.getTime() / 1000}.${payload}`);
        const expectedSignature = base64.encode(sha256.hmac(this.key, toSign));
        return `v1,${expectedSignature}`;
    }
    verifyTimestamp(timestampHeader) {
        const now = Math.floor(Date.now() / 1000);
        const timestamp = parseInt(timestampHeader, 10);
        if (isNaN(timestamp)) {
            throw new WebhookVerificationError("Invalid Signature Headers");
        }
        if (now - timestamp > WEBHOOK_TOLERANCE_IN_SECONDS) {
            throw new WebhookVerificationError("Message timestamp too old");
        }
        if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
            throw new WebhookVerificationError("Message timestamp too new");
        }
        return new Date(timestamp * 1000);
    }
}
exports.Webhook = Webhook;
Webhook.prefix = "whsec_";
//# sourceMappingURL=index.js.map