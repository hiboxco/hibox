import { Configuration, ApplicationOut, ListResponseApplicationOut, ApplicationIn, ListResponseEndpointOut, EndpointOut, EndpointIn, EndpointUpdate, EndpointSecretOut, EndpointSecretRotateIn, EndpointHeadersIn, EndpointHeadersOut, RecoverIn, MessageOut, MessageIn, ListResponseMessageOut, DashboardAccessOut, ListResponseEndpointMessageOut, ListResponseMessageEndpointOut, ListResponseMessageAttemptEndpointOut, ListResponseMessageAttemptOut, MessageAttemptOut, MessageStatus, ListResponseEventTypeOut, EventTypeIn, EventTypeOut, EventTypeUpdate } from "./openapi/index";
export * from "./openapi/models/all";
export * from "./openapi/apis/exception";
export interface SvixOptions {
    debug?: boolean;
    serverUrl?: string;
}
export declare class Svix {
    readonly _configuration: Configuration;
    readonly authentication: Authentication;
    readonly application: Application;
    readonly endpoint: Endpoint;
    readonly eventType: EventType;
    readonly message: Message;
    readonly messageAttempt: MessageAttempt;
    constructor(token: string, options?: SvixOptions);
}
declare class Authentication {
    private readonly api;
    constructor(config: Configuration);
    dashboardAccess(appId: string): Promise<DashboardAccessOut>;
    logout(): Promise<void>;
}
interface ListOptions {
    iterator?: string;
    limit?: number;
}
export declare type ApplicationListOptions = ListOptions;
export declare type EndpointListOptions = ListOptions;
export interface EventTypeListOptions extends ListOptions {
    withContent?: boolean;
    includeArchived?: boolean;
}
export interface MessageListOptions extends ListOptions {
    eventTypes?: string[];
    before?: Date;
}
export interface MessageAttemptListOptions extends ListOptions {
    status?: MessageStatus;
    eventTypes?: string[];
    before?: Date;
}
declare class Application {
    private readonly api;
    constructor(config: Configuration);
    list(options?: ApplicationListOptions): Promise<ListResponseApplicationOut>;
    create(applicationIn: ApplicationIn): Promise<ApplicationOut>;
    get(appId: string): Promise<ApplicationOut>;
    update(appId: string, applicationIn: ApplicationIn): Promise<ApplicationOut>;
    delete(appId: string): Promise<void>;
}
declare class Endpoint {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, options?: EndpointListOptions): Promise<ListResponseEndpointOut>;
    create(appId: string, endpointIn: EndpointIn): Promise<EndpointOut>;
    get(appId: string, endpointId: string): Promise<EndpointOut>;
    update(appId: string, endpointId: string, endpointUpdate: EndpointUpdate): Promise<EndpointOut>;
    delete(appId: string, endpointId: string): Promise<void>;
    getSecret(appId: string, endpointId: string): Promise<EndpointSecretOut>;
    rotateSecret(appId: string, endpointId: string, endpointSecretRotateIn: EndpointSecretRotateIn): Promise<void>;
    recover(appId: string, endpointId: string, recoverIn: RecoverIn): Promise<void>;
    getHeaders(appId: string, endpointId: string): Promise<EndpointHeadersOut>;
    updateHeaders(appId: string, endpointId: string, endpointHeadersIn: EndpointHeadersIn): Promise<void>;
    patchHeaders(appId: string, endpointId: string, endpointHeadersIn: EndpointHeadersIn): Promise<void>;
}
declare class EventType {
    private readonly api;
    constructor(config: Configuration);
    list(options?: EventTypeListOptions): Promise<ListResponseEventTypeOut>;
    get(eventTypeName: string): Promise<EventTypeOut>;
    create(eventTypeIn: EventTypeIn): Promise<EventTypeOut>;
    update(eventTypeName: string, eventTypeUpdate: EventTypeUpdate): Promise<EventTypeOut>;
    delete(eventTypeName: string): Promise<void>;
}
declare class Message {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, options?: MessageListOptions): Promise<ListResponseMessageOut>;
    create(appId: string, messageIn: MessageIn): Promise<MessageOut>;
    get(appId: string, msgId: string): Promise<MessageOut>;
}
declare class MessageAttempt {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, msgId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageAttemptOut>;
    get(appId: string, msgId: string, attemptId: string): Promise<MessageAttemptOut>;
    resend(appId: string, msgId: string, endpointId: string): Promise<void>;
    listAttemptedMessages(appId: string, endpointId: string, options?: MessageAttemptListOptions): Promise<ListResponseEndpointMessageOut>;
    listAttemptedDestinations(appId: string, msgId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageEndpointOut>;
    listAttemptsForEndpoint(appId: string, msgId: string, endpointId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageAttemptEndpointOut>;
}
declare class ExtendableError extends Error {
    constructor(message: any);
}
export declare class WebhookVerificationError extends ExtendableError {
    constructor(message: string);
}
export interface WebhookRequiredHeaders {
    "svix-id": string;
    "svix-timestamp": string;
    "svix-signature": string;
}
export interface WebhookUnbrandedRequiredHeaders {
    "webhook-id": string;
    "webhook-timestamp": string;
    "webhook-signature": string;
}
export declare class Webhook {
    private static prefix;
    private readonly key;
    constructor(secret: string);
    verify(payload: string, headers_: WebhookRequiredHeaders | WebhookUnbrandedRequiredHeaders | Record<string, string>): unknown;
    sign(msgId: string, timestamp: Date, payload: string): string;
    private verifyTimestamp;
}
